import Blas as bl
import math as ma
import numpy as np

# **********************************************************************
def preDiag(a,neq):
  """
*********************************************************************
* DATA DE CRIACAO  : 28/02/2019                                     *
* DATA DE MODIFICAO: 00/00/0000                                     *
* ----------------------------------------------------------------- *
* preDiag: monta o precondicionador diagonal (Jacobi)               * 
* ----------------------------------------------------------------- *
* Parametros de entrada:                                            *
* ----------------------------------------------------------------- *
* a - matriz de coefientes n x n                                    *
* neq - numero de linhas e colunas                                  *
* ----------------------------------------------------------------- *
* Parametros de saida:                                              *
* ----------------------------------------------------------------- *
* m    - retorna o inverso do coefiente da diagonal                 *
* ----------------------------------------------------------------- *
* OBS:                                                              *
* ----------------------------------------------------------------- *
* m e um vetor e a uma matriz quadrade cheia                        *
*********************************************************************
  """

  m = [0.e0]*neq

  for i in range(0,neq):
    m[i] = 1.0/a[i][i]

  return m
# **********************************************************************
#
# **********************************************************************
def preDiagNumpy(a,preCond,neq):
  """
*********************************************************************
* DATA DE CRIACAO  : 28/02/2019                                     *
* DATA DE MODIFICAO: 00/00/0000                                     *
* ----------------------------------------------------------------- *
* preDiagNumy: monta o precondicionador diagonal                    *   
* ----------------------------------------------------------------- *
* Parametros de entrada:                                            *
* ----------------------------------------------------------------- *
* a       - matriz de coefientes n x n                              *
* preCond - tipo do precondicionador                                *  
*         0 - nenhum                                                *
*         1 - Jacobi                                                *
* neq     - numero de linhas e colunas                              *
* ----------------------------------------------------------------- *
* Parametros de saida:                                              *
* ----------------------------------------------------------------- *
* m    - retorna o inverso do coefiente da diagonal                 *
* ----------------------------------------------------------------- *
* OBS:                                                              *
* ----------------------------------------------------------------- *
* m e um vetor e a uma matriz quadrade cheia                        *
*********************************************************************
  """

  if preCond == 0:
    m = np.ones((neq,1),dtype=float) 

  elif preCond == 1:
    m = np.zeros((neq,1),dtype=float)
    for i in range(0,neq):
      m[i,0] = 1.0/a[i,i]

  return m
# **********************************************************************
#
# **********************************************************************
def preCond(m,x,neq):

  """
*********************************************************************
* DATA DE CRIACAO  : 28/02/2019                                     *
* DATA DE MODIFICAO: 00/00/0000                                     *
* ----------------------------------------------------------------- *
* preCond: faz o multiplicao                                        *
* ----------------------------------------------------------------- *
* Parametros de entrada:                                            *
* ----------------------------------------------------------------- *
* m   - matriz de coefientes n x n                                  *
* x   - matriz de coefientes n x n                                  *
* neq - numero de linhas e colunas                                  *
* ----------------------------------------------------------------- *
* Parametros de saida:                                              *
* ----------------------------------------------------------------- *
* m    - retorna o inverso do coefiente da diagonal                 *
* ----------------------------------------------------------------- *
* OBS:                                                              *
* ----------------------------------------------------------------- *
*********************************************************************
  """

  y = np.zeros((neq,1),dtype=float)

  for i in range(0,neq):
    y[i,0] = m[i,0]*x[i,0]

  return y
# **********************************************************************
#
# **********************************************************************
def pcg(a,b,x=None,tol=1.e-14,maxIt=10000, preC=1
       ,new=True,fHist=True,nameLog='log.Txt'):

  """
*********************************************************************
* DATA DE CRIACAO  : 28/02/2019                                     *
* DATA DE MODIFICAO: 00/00/0000                                     *
* ----------------------------------------------------------------- *
* pcg : gradiente conjugado com precondicionador diagonal           *
* ----------------------------------------------------------------- *
* Parametros de entrada:                                            *
* ----------------------------------------------------------------- *
* a - matriz de coefientes n x n                                    *
* b - vetor independente                                            *
* x - chute inicial                                                 *
* tol - tolerancia do solver                                        *
* maxIt - maximo de itracoes                                        *
* new   - true inicialia com zeros                                  *
* ----------------------------------------------------------------- *
* Parametros de saida:                                              *
* ----------------------------------------------------------------- *
* x - vetor solucao                                                 *
* ----------------------------------------------------------------- *
* OBS:                                                              *
* ----------------------------------------------------------------- *
* Utilizando python puro                                            *
*********************************************************************
  """
# ... abre o arquivo de log
  if fHist :
      fileLog = open(nameLog,'w')
# ......................................................................

# ...
  neq = len(b)
# ......................................................................

# ...
  a = a.tolist()
  b = b.tolist()
# ......................................................................

# ... precond Jacobi
  if preC == 1:
    m = preDiag(a,neq)
  elif preC == 0:
    m = [1.0]*neq
# ...................................................................... 

# ...
  z = [0.0]*neq
  r = [0.0]*neq
  p = [0.0]*neq
# ......................................................................

# ...
  if x == None:
    x = neq*[0.e0]
  else:
    if new:
      for i in range(0,neq):
        x[i] = 0.e0
# ......................................................................

# ...
  for i in range(0,neq):
    z[i] = b[i]*m[i]
# ......................................................................

# ...
  d0 = d = bl.dot1(b,b)
  norm_b = ma.sqrt(d)
  conv   = tol*norm_b
# ......................................................................

# ... Ax0
  z = bl.matvec1(a,x)
# ......................................................................

#...
  if fHist:
      fileLog.write("{0:10d},{1:.14e}\n".format(0,ma.sqrt(d/d0)))
# ......................................................................

# ...
  for i in range(0,neq):
# ... r0 = b - Ax0
    r[i] = b[i] - z[i]
# ... z0 = (M-1)r0
    z[i] = r[i]*m[i]
# ... p0 = r0
    p[i] = z[i]
# ......................................................................

# ... ( r(0),z(0) ) = ( r(0), (M-1)r0 )
  d = bl.dot1(r,z)
# ......................................................................

# ...
  jj = 1
  for j in range(1,maxIt):
# ... z = Ap
    z = bl.matvec1(a,p)
# ......................................................................

# ... alpha =( r(j),z(j) ) / ( Ap(j), p(j) ))
    alpha = d/bl.dot1(z,p)
# ......................................................................

# ...
    for i in range(0,neq):
# ... x(j+1) = x(j) + alpha*p
      x[i] = x[i] + alpha*p[i]
# ... r(j+1) = r(j) - alpha*Ap
      r[i] = r[i] - alpha*z[i]
# ... z  = (M-1)r0
      z[i] = r[i]*m[i]
# ......................................................................

# ... ( r(j+1),(M-1)r(j+1) ) = ( r(j+1),z )
    di   = bl.dot1(r,z)
# ... beta = ( r(j+1),(M-1)r(j+1) ) / ( r(j),r(j) ) 
    beta = di/d
# ......................................................................

# ...
    for i in range(0,neq):
# ... p(j+1) = (M-1)r(j+1) + beta*p(j) = z + beta*p(j)
      p[i] = z[i] + beta*p[i]
# ......................................................................

# ...    
    d = di
#...
    if fHist:
        fileLog.write("{0:10d},{1:.14e}\n".format(j,ma.sqrt(d/d0)))
# ......................................................................

# ...
    if ma.sqrt(d) < conv:
      break
# ......................................................................

# ...
    if jj == 500 :
      jj = 0
      print(j,ma.sqrt(d),conv) 
    jj = jj + 1
# ......................................................................

# ......................................................................

# ... Energy norm: x*Kx
  z = bl.matvec2(a,x)
  xkx = bl.dot1(x,z)
# ......................................................................

# ...
  stry = "(PCG) solver:\n"
  stry+= "Solver tol           = {0:e}\n"
  stry+= "Number of equations  = {1}\n"
  stry+= "Number of iterations = {2}\n"
  stry+= "xKx                  = {3:e}\n"
  print(stry.format(tol,neq,j,xkx))
# ......................................................................
        
  return x
# **********************************************************************
#
# **********************************************************************
def pcgNumpy(a,b,x=None,tol=1.e-14,maxIt=10000,preC=1\
            ,new=True,fHist=True,nameLog='log.txt'):

  """
*********************************************************************
* DATA DE CRIACAO  : 28/02/2019                                     *
* DATA DE MODIFICAO: 00/00/0000                                     *
* ----------------------------------------------------------------- *
* pcgNumpy : gradiente conjugado com precondicionador diagonal      *
* ----------------------------------------------------------------- *
* Parametros de entrada:                                            *
* ----------------------------------------------------------------- *
* a - matriz de coefientes n x n                                    *
* b - vetor independente                                            *
* x - chute inicial                                                 *
* tol - tolerancia do solver                                        *
* maxIt - maximo de itracoes                                        *
* new   - true inicialia com zeros                                  *
* preCond - tipo do precondicionador                                *  
*         0 - nenhum                                                *
*         1 - Jacobi                                                *
* ----------------------------------------------------------------- *
* Parametros de saida:                                              *
* ----------------------------------------------------------------- *
* x - vetor solucao                                                 *
* ----------------------------------------------------------------- *
* OBS:                                                              *
* ----------------------------------------------------------------- *
* Utilizando numpy                                                  *
*********************************************************************
  """
# ... abre o arquivo de log
  if fHist :
    fileLog = open(nameLog,'w')
# ......................................................................

# ...
  neq = len(b)
# ......................................................................

# ...
  if type(a) is type([]):
    print('Conv List a for numpy matrix')
    a = np.asarray(a)
# ...
  if type(x) is type([]):
    print('Conv List a for numpy array')
    x = np.asarray(x)
# ...    
  if type(b) is type([]):
    print('Conv List a for numpy array')
    b = np.asarray(b)
# ......................................................................

# ...
  b      = b.reshape((neq,1))
# ......................................................................

# ... precond Jacobi
  m = preDiagNumpy(a,preC,neq)
# ...................................................................... 

# ...
  if new:
    x = np.zeros((neq,1),dtype=float)
# ......................................................................

# ...
  d0     = d = bl.dot1(b,b)
  norm_b = ma.sqrt(d)
  conv   = tol*norm_b
# ......................................................................

#...
  if fHist:
    fileLog.write("{0:10d},{1:.14e}\n".format(0,ma.sqrt(d/d0)))
# ......................................................................

# ...
# ... r0 = b - Ax0
  r = b - a@x  
# ... z0 = (M-1)r0
  z = preCond(r,m,neq)  
# ... p0 = r0
  p = z  
# ......................................................................

# ... ( r(0),z(0) ) = ( r(0), (M-1)r0 )
  d = float(r.T*z)
# ......................................................................

# ...
  jj = 1
  for j in range(1,maxIt):

# ...
#    z = np.dot(a,p)
    z = a@p
# ......................................................................

# ... alpha =( r(j),z(j) ) / ( Ap(j), p(j) ))
    alpha = d/float(z.T*p)
# ......................................................................

# ...
# ... x(j+1) = x(j) + alpha*p
    x += alpha*p
# ... r(j+1) = r(j) - alpha*Ap
    r -= alpha*z
# ... z  = (M-1)r0
    z = preCond(r,m,neq)
# ......................................................................

# ... ( r(j+1),(M-1)r(j+1) ) = ( r(j+1),z )
    di   = float(r.T*z)
# ... beta = ( r(j+1),(M-1)r(j+1) ) / ( r(j),r(j) ) 
    beta = di/d
# ......................................................................

# ... p(j+1) = (M-1)r(j+1) + beta*p(j) = z + beta*p(j)
    p = z + beta*p
# ......................................................................

# ...    
    d = di
#...    
    if fHist:
      fileLog.write("{0:10d},{1:.14e}\n".format(j,ma.sqrt(d/d0)))
# ......................................................................

# ...
    if ma.sqrt(d) < conv:
      break
# ......................................................................

# ...
    if jj == 500 :
      jj = 0
      print(j,ma.sqrt(d),conv) 
    jj = jj + 1
# ......................................................................

# ......................................................................

# ... Energy norm: x*Kx
  z   = a@x
  xkx = float(x.T*z)
# ......................................................................

# ...
  stry = "(PCG) solver:\n"
  stry+= "Solver tol           = {0:e}\n"
  stry+= "Number of equations  = {1}\n"
  stry+= "Number of iterations = {2}\n"
  stry+= "xKx                  = {3:e}\n"
  print(stry.format(tol,neq,j,xkx))
# ......................................................................

# ... fecha o arquivo de log
  if fHist :
    fileLog.close()
# ......................................................................
        
  return x
# **********************************************************************
